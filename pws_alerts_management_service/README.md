# One Mind Alerts Management Service

This component implements an API and a DB model that is able to receive,
return and modify Alerts and Rules. Alerts are stored in
an operational database (Postgres) and streamed in real-time using SSE.

## Technologies

The API and DB ORM is implemented in Python 3 with Eve
and SQLAlchemy, with the add-on of GeoAlchemy2, which provides
support for GIS artifacts, and Flask-SSE for HTTP SSE streaming.

Eve is a API framework built on top of Flask.

The component is launched using Gunicorn and gevent (for SSE).

## Usage

This API can be launched locally (usually in a virtualenv) or in
a Docker container.

In both cases you need to have all requirements installed, and two
environmental variables present:

* PROJECT_ROOT, pointing to the superior level of the source folder 
'alerts_api', relative or absolute route.
* FLASK_APP, point to the launcher main.py, relative or absolute.

By default, the internal port of the API is ```:5000```. To connect to the 
stream use the endpoint ```/alert_stream```

### Run in Docker:
```make run```

### Run locally
```gunicorn alerts_api.main:app --worker-class gevent --bind 0.0.0.0:5000```

There should be a FLASK_APP environmental variable pointing to
the route ```alerts_api/main.py```.

For more information checkout the Makefile.

## API endpoints

Alerts and Rules Collection endpoints are in the following routes
```
alerts/
rules/
```

In a typical local environment, the route will be:

```http://127.0.0.1:5000/alerts```

Use ```0.0.0.0```, ```localhost```, or a full-flegged URL depending on the 
visibility and environment it is deployed.

In the Collection endpoints you can use GET to retrieve the collection
and POST to add and item.

To retrieve a single item, use the next url, replacing {alert_id} with
the wanted id.

```http://127.0.0.1:5000/alerts/{alert+_d}```

To retrieve items depending on parameters, use Eve's filtering and sorting
capabilities:
http://docs.python-eve.org/en/latest/features.html#filtering

### Insert new alerts through CLI

Using the Flask CLI (powered by Click) you can insert an Alert in a certain
location to use it just run from the project folder (locally or in a
Docker container)

```flask new_alert $LATITUDE $LONGITUDE```

Example: _flask new alert 42.12345 2.6789_

In order for the Flask CLI to work you need the following environmental
variable: ```FLASK_APP=./alerts_api/main.py```.

Note: locally, you need to enter the virtualenv where Eve/Flask is
installed.


### Insert elements via DB and via API

To insert elements into the API you can use external tools like Curl or
Postman, or do it programatically - with requests in Python.

A sample of the JSON of a POST call is presented below

If you want to populate the Database you better use the artifacts already
present in the API:

- alerts_api.database::ORMClient.insert_alert
- tests.fixtures::AlertFactory2DB

To insert alerts with the ORM you need to provide a dictionary with valid
values (see POST Fields section) or use a Factory present in the test
fixtures, see a code snippet:

~~~python
from alerts_api.database import ORMClient
from configmanager import ConfigManager
from tests.fixtures import AlertDictFactory

db_conf = ConfigManager().get_specific_configuration("database)
orm_client  = ORMClient(**db_conf)
new_alert = AlertDictFactory(id=mock_alert_1, the_geom=point_factory(42.2, 2.03))
orm_client.insert_alert(new_alert)
~~~

The AlertFactory2DB is capable of automatically insert Alerts if provided
with a DB session:

~~~python
from alerts_api.database import create_db_session
from configmanager import ConfigManager
from tests.fixtures import AlertFactory2DB, point_factory

db_conf = ConfigManager().get_specific_configuration("database)
db_session = create_db_session(db_conf)
AlertFactory2DB._meta.sqlalchemy_session = db.session
AlertFactory2DB(id=mock_alert_1, the_geom=point_factory(42.2, 2.03))
~~~

In both factories, non-explicit values will be replaced by their defaults
or not included.

#### POST and PATCH Fields

Depending on your intentions you would create new alerts (POST) or
modify existing ones (PATCH).

##### Autogenerated Fields

Many fields are inserted automatically, so refrain to add them unless you
want to force-insert them.

Autogenerated Fields are:
  - id
  - created_at
  - updated_at

##### PATCH fields

Other fields are meant for interaction only as the Alert evolve in time,
and should not be inserted on POST but on PATCH calls (as updates). Those
fields are:
  - status
  - operative_status: 0 (new), 10 (seen), 20 (attended), 30 (resolved)
  - assigned_to
  - updated_by
  - resolved_by
  - resolved_at

Many fields are inserted automatically (f.i. id, create_at) but they can
be force-inserted if you need to (generally not recommended).

In general do not insert empty string in fields you don't have an interest,
the API will fill them up with a reasonable default value or a null (None).

## API documentation

API documentations is generated using Eve-Swagger. To do so, launch the api in DEBUG mode
and access the endpoint '/api-docs'

## Running

### Docker
`make run` and the RabbitMQ queue will be setup on port `:5672` and a
Postgres database on port `:5432`. A browsable interface of the queue
can be seen on port `:15672`.

### Locally

Assuming the dockers are launched, from the project folder use one of the
ones bellow:
~~~bash
flask run
gunicorn alerts_api.main:app --worker-class gevent --bind 0.0.0.0:5000
~~~

## Testing

Testing needs launching docker containers with _docker-compose.unittests.yml_
before running.

Use _pytest_ locally or `make run-unittests` for docker and the tests
will be run automatically.

Sometimes pytest cannot import the package (alerts_api folder) correctly. In
that case define the Python path:

```PYTHONPATH=./ pytest```

## Known issues

### Serializing WKB

It has not been posible to serialize the Geometry Point directly with
Eve. To work around it, it has been patched to GeoJSON before the
serialization.

Deserialization the Geojson and transforming to GeoAlchemy2 artifacts
has been achieved.

### Open connection after unit tests

In a non-deterministic manner, unit tests raise and Error when
dropping the Database.

### DB session outside app context

The DB session is created outside the Flask/Eve app context in some
cases.

Once the knowledge on Flask is improved, it should be resolved.

### Fixture Dict factory patched with WKT elements

Depending on where do you insert data, you need to insert Geo
While the custom ORM client is used, it needs WKT geometries, instead
of GeoJsons, this should change once the consumer is removed.
